# MQ5 Sensor Library
this markdown is to document my work on the mq5 sensor

This markdown was generated using the help of chatGPT where this prompt was used

`for those four files, I want to documet them with markdown file, give me a markdown that contains snippest from the code and explain each, like start with the struct parameters and explain them in a table, then explain why use the buffer and how the buffer works with thecode (give a scenario with numbers for the buffer) like you understand me do it your way`

while this markdown were generated by chatGPT, it was completly checked and confirmed line by line

**note: the code was totally manual generated, no chatGPT**

**note: this markdown last edit was 12/16/2025 - 1:40 am, any adjustment after is not documented yet**

## 1) MQ5 state struct (MQ5.h)

### 1.1 Struct snippet

```cpp
typedef struct {
    uint8_t  analog_pin;
    uint32_t warmup_ms;
    uint32_t start_ms;

    uint16_t samplesNumber;
    uint32_t sum;
    uint16_t *buffer;
    uint16_t index;
    bool     filled;

    uint16_t baseline;
    uint16_t delta_threshold;
} MQ5;
```

### 1.2 Fields explained (table)

| Field | Type | What it means | How it’s used |
|---|---:|---|---|
| `analog_pin` | `uint8_t` | ADC pin for MQ-5 analog output | Used by `analogRead()` in `MQ5_readCurrentValue()` |
| `warmup_ms` | `uint32_t` | Warm-up duration in ms | Checked by `MQ5_isWarmedUp()` |
| `start_ms` | `uint32_t` | Timestamp at init | Set to `millis()` in `MQ5_init()` |
| `samplesNumber` | `uint16_t` | Moving average window size (N) | Defines buffer length + wrap point |
| `sum` | `uint32_t` | Running sum of values in the active window | Enables O(1) average |
| `buffer` | `uint16_t*` | Circular buffer storing raw ADC samples | Stores the last N readings |
| `index` | `uint16_t` | Current write position in `buffer` | Incremented each update, wraps at N |
| `filled` | `bool` | Becomes `true` once the buffer wraps at least once | Controls whether we average N samples or “so far” samples |
| `baseline` | `uint16_t` | User-captured reference average value | Set by `MQ5_captureBaseline()` |
| `delta_threshold` | `uint16_t` | Leak threshold (difference from baseline) | Used in `MQ5_leakDetected()` |

---

## 2) Library initialization (MQ5.cpp)

### 2.1 Init snippet

```cpp
void MQ5_init(MQ5 *s,
              uint8_t analog_pin,
              uint16_t *buffer,
              uint16_t samplesNumber,
              uint32_t warmup_ms,
              uint16_t delta_threshold)
{
    s->analog_pin = analog_pin;
    s->warmup_ms = warmup_ms;
    s->start_ms  = millis();

    s->samplesNumber = (samplesNumber == 0) ? 1 : samplesNumber;
    s->buffer = buffer;
    s->index  = 0;
    s->sum    = 0;
    s->filled = false;

    for (uint16_t i = 0; i < s->samplesNumber; i++)
        s->buffer[i] = 0;

    s->baseline = 0;
    s->delta_threshold = delta_threshold;
}
```

### 2.2 What happens here (why it’s done this way)

- **Stores configuration**: `analog_pin`, `warmup_ms`, `delta_threshold`.
- **Locks start time**: `start_ms = millis()` so warm-up check doesn’t need external timing.
- **Prevents invalid window size**: if `samplesNumber == 0`, forces it to `1`.
- **Resets averaging state**:
  - `index = 0`, `sum = 0`, `filled = false`
  - Clears the buffer to zeros (important for deterministic startup)
- **Baseline starts at 0** until you explicitly capture it.

---

## 3) Reading the sensor (clamped ADC)

### 3.1 Raw read snippet

```cpp
uint16_t MQ5_readCurrentValue(const MQ5 *s) {
    int v = analogRead(s->analog_pin);
    if (v < 0) v = 0;
    if (v > 1023) v = 1023;
    return (uint16_t)v;
}
```

### 3.2 Why clamp?

Even though AVR `analogRead()` is normally 0..1023, clamping makes the function robust if:
- platform differences return odd values
- you later change ADC backend
- some transient bug causes negatives

So downstream code always sees a valid 10-bit range value.

---

## 4) The moving-average buffer (core logic)

### 4.1 Update snippet

```cpp
void MQ5_update(MQ5 *s) {
    uint16_t x = MQ5_readCurrentValue(s);

    s->sum -= s->buffer[s->index];
    s->buffer[s->index] = x;
    s->sum += x;

    s->index++;
    if (s->index >= s->samplesNumber) {
        s->index = 0;
        s->filled = true;
    }
}
```

### 4.2 Why use a buffer at all?

MQ sensors are **noisy**. If you trigger based on raw reads, you’ll get false detections from:
- airflow turbulence
- heater drift
- ADC noise / power ripple

The buffer + average makes your “signal” stable.

### 4.3 Why the running sum trick?

A naive average recomputes:
- `avg = (buf[0] + buf[1] + ... + buf[N-1]) / N` every time → O(N)

Your code does:
- subtract old value
- add new value
- divide by N (or filled count)

That’s **O(1)** per update — perfect for periodic scheduling (10 Hz or faster).

---

## 5) How the circular buffer behaves (scenario with numbers)

Assume:
- `samplesNumber = 5`
- buffer starts as `[0, 0, 0, 0, 0]`
- `sum = 0`, `index = 0`, `filled = false`

Now sensor reads arrive (each call to `MQ5_update()` takes one reading).

### 5.1 First 5 updates (buffer not yet wrapped)

Readings: `500, 510, 520, 530, 540`

| Update # | New `x` | Buffer after write | `sum` | `index` | `filled` |
|---:|---:|---|---:|---:|---|
| 1 | 500 | [500, 0, 0, 0, 0] | 500 | 1 | false |
| 2 | 510 | [500, 510, 0, 0, 0] | 1010 | 2 | false |
| 3 | 520 | [500, 510, 520, 0, 0] | 1530 | 3 | false |
| 4 | 530 | [500, 510, 520, 530, 0] | 2060 | 4 | false |
| 5 | 540 | [500, 510, 520, 530, 540] | 2600 | 0 (wrap) | true |

At update #5:
- `index` wraps back to 0
- `filled` becomes `true` (now you have a full window of N samples)

### 5.2 Update #6 (overwriting the oldest sample)

New reading: `600`

Before writing at `index = 0`, the old value there is `500`.
Your code does:
- `sum = sum - 500` → `2600 - 500 = 2100`
- write `600` into buffer[0]
- `sum = sum + 600` → `2100 + 600 = 2700`

Buffer becomes: `[600, 510, 520, 530, 540]`  
Now the last 5 samples average is: `2700 / 5 = 540`

This is the key idea: **the average always represents the latest N readings once filled is true.**

---

## 6) Average calculation (important detail)

### 6.1 Average snippet

```cpp
uint16_t MQ5_readAverage(const MQ5 *s) {
    uint16_t n = s->filled ? s->samplesNumber : (s->index == 0 ? 1 : s->index);
    return (uint16_t)(s->sum / n);
}
```

### 6.2 What `n` is doing

There are two phases:

**Phase A — before buffer is full (`filled == false`)**
- You don’t want to divide by the full `samplesNumber`, because most of the buffer is still zeros.
- So you divide by the number of samples you *actually inserted* so far: `index`.
- Special-case: if `index == 0`, return `n = 1` (prevents divide-by-zero if user reads avg before any update).

**Phase B — after first wrap (`filled == true`)**
- Now the buffer always contains the last N real readings.
- So `n = samplesNumber` always.

---

## 7) Warm-up logic

### 7.1 Warm-up check snippet

```cpp
bool MQ5_isWarmedUp(const MQ5 *s) {
    return (uint32_t)(millis() - s->start_ms) >= s->warmup_ms;
}
```

### 7.2 Why warm-up matters

MQ sensors drift a lot at startup because the heater needs to stabilize.
So your app should do something like:
- keep calling `MQ5_update()` during warm-up
- ignore leak decisions until `MQ5_isWarmedUp()` returns true
- then capture baseline in a known clean condition

---

## 8) Baseline capture + delta + leak detection

### 8.1 Baseline capture snippet

```cpp
void MQ5_captureBaseline(MQ5 *s) {
    s->baseline = MQ5_readAverage(s);
}
```

Baseline is a “snapshot” of the average in clean air. It’s manual on purpose:
- you decide when the environment is clean
- you can recapture if conditions change (season, humidity, sensor aging, etc.)

### 8.2 Delta snippet

```cpp
int32_t MQ5_delta(const MQ5 *s) {
    return (int32_t)MQ5_readAverage(s) - (int32_t)s->baseline;
}
```

Delta is “how far above baseline” you are.
Using `int32_t` prevents underflow if avg < baseline.

### 8.3 Leak decision snippet

```cpp
bool MQ5_leakDetected(const MQ5 *s) {
    return MQ5_delta(s) >= (int32_t)s->delta_threshold;
}
```

Example:
- baseline = 520
- avg = 610
- delta = 90
- threshold = 80 → leakDetected() = true

---

## 9) Timer1 CTC setup for 10 Hz (gas_timer.c)

### 9.1 Setup snippet

```c
void MQ5_timerSetup()
{
    cli();

    TCCR1A = 0;
    TCCR1B = 0;

    TCNT1 = 0;

    OCR1A = 1562; // 15625 × 0.1 = 1562

    TCCR1B |= (1 << WGM12); //  CTC mode
    TCCR1B |= (1 << CS12) | (1 << CS10); // 1024 pre-scaller
    TIMSK1 |= (1 << OCIE1A); // Enable output compare A

    sei();
}
```

### 9.2 What this config means

- **Timer1 in CTC mode** (`WGM12 = 1`): timer resets when it matches `OCR1A`
- **Prescaler = 1024** (`CS12=1`, `CS10=1`)
- **Compare match interrupt enabled** (`OCIE1A`)

With 16 MHz clock:
- Timer tick frequency after prescale ≈ `16,000,000 / 1024 = 15625 Hz`
- If you want 0.1 sec (10 Hz), you need ~1562.5 ticks → you used `OCR1A = 1562`

So you get an interrupt approximately every 0.1 seconds.

### 9.3 Correct usage pattern (important)

Keep ISR short:
- ISR should only set a flag

Then in `loop()`:
- if flag set → clear flag → call `MQ5_update()` (and any logic)

This prevents long ISR time and avoids messing with ADC / serial inside interrupts.

---

## 10) Quick “mental model” summary

- `MQ5_update()` maintains a circular window of the last `samplesNumber` ADC readings.
- `sum` is always the sum of the window values (or partial window before wrap).
- `MQ5_readAverage()` divides by the right count depending on whether the buffer is full.
- Baseline is a saved average in clean air.
- Delta is average minus baseline.
- Leak is delta >= threshold.
- Timer1 is configured to give you a stable, predictable update rate (10 Hz).

